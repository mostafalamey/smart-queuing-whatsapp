# Enterprise Analytics Enhancement Plan üìä

**Project**: Smart Queue System Analytics Upgrade  
**Version**: 1.0  
**Date**: September 1, 2025  
**Status**: Planning Phase

## üéØ Executive Summary

Transform the current basic analytics system into an enterprise-grade business intelligence platform with predictive capabilities, real-time insights, and automated reporting. The plan is structured in 4 phases over 9 weeks.

## üìà Current State Analysis

### **Strengths of Current Implementation**

- ‚úÖ Well-structured architecture with clean separation (features, hooks, types)
- ‚úÖ Dual mode system (Standard vs Enhanced analytics toggle)
- ‚úÖ Role-based access control for analytics
- ‚úÖ Real-time capabilities via Supabase integration
- ‚úÖ Responsive design with Tailwind CSS
- ‚úÖ Basic KPI tracking and visualization

### **Critical Enhancement Areas**

- ‚ùå Limited to basic statistical analysis
- ‚ùå No predictive modeling capabilities
- ‚ùå Missing business intelligence insights
- ‚ùå No automated alerting system
- ‚ùå Limited historical analysis depth
- ‚ùå No custom reporting functionality

---

## üöÄ Implementation Phases

## **Phase 1: Core Analytics Engine** ‚è±Ô∏è 2 Weeks

### **Foundation for advanced analytics capabilities**

### **Deliverables**

1. **Statistical Analysis Engine** - Mathematical models for trend analysis
2. **Advanced Data Aggregation** - Sophisticated data processing pipelines
3. **Real-time Metric Streaming** - Live analytics dashboard updates
4. **Enhanced Visualization** - Predictive overlays on existing charts

### **Technical Implementation**

#### 1.1 Statistical Analysis Engine

```typescript
// Location: admin/src/lib/analytics/StatisticalAnalysisEngine.ts
export class StatisticalAnalysisEngine {
  // Moving averages for trend analysis
  static calculateMovingAverage(data: number[], window: number): number[];

  // Seasonal decomposition
  static decomposeTimeSeries(data: TimeSeriesPoint[]): SeasonalDecomposition;

  // Predictive modeling
  static linearRegression(data: Point[]): RegressionResult;

  // Outlier detection
  static detectOutliers(
    data: number[],
    method: "iqr" | "zscore"
  ): OutlierResult[];

  // Correlation analysis
  static calculateCorrelation(x: number[], y: number[]): CorrelationResult;
}
```

#### 1.2 Advanced Data Processing Hook

```typescript
// Location: admin/src/app/analytics/hooks/useAdvancedAnalyticsProcessing.ts
export const useAdvancedAnalyticsProcessing = () => {
  const processHistoricalData = useMemo(() => {
    return (rawData: TicketData[]) => {
      const timeSeriesData = aggregateByTimeIntervals(rawData, "hour");
      const seasonalPatterns = detectSeasonalPatterns(rawData);
      const outlierDetection = identifyOutliers(rawData);

      return {
        trends: calculateTrends(timeSeriesData),
        predictions: generatePredictions(timeSeriesData),
        insights: extractBusinessInsights(rawData),
        anomalies: outlierDetection,
      };
    };
  }, []);
};
```

#### 1.3 Real-Time Analytics Dashboard

```typescript
// Location: admin/src/app/analytics/components/RealTimeAnalyticsDashboard.tsx
export const RealTimeAnalyticsDashboard: React.FC = () => {
  // Live metrics streaming
  // Alert threshold monitoring
  // Connection status indicators
  // Automatic refresh mechanisms
};
```

#### 1.4 Enhanced Visualization Components

```typescript
// Location: admin/src/app/analytics/components/charts/
-HeatmapChart.tsx - // Peak hours visualization
  PredictiveChart.tsx - // Historical + predictions
  TrendAnalysisChart.tsx - // Multi-layered trend analysis
  CorrelationMatrix.tsx; // Service correlation analysis
```

### **Phase 1 Success Criteria**

- [ ] Real-time metrics update within 2 seconds
- [ ] Historical trend analysis with 95% accuracy
- [ ] Outlier detection identifies anomalies correctly
- [ ] Visual charts load under 1 second
- [ ] Statistical calculations process 10K+ records efficiently

---

## **Phase 2: Business Intelligence Engine** ‚è±Ô∏è 2 Weeks

### **Automated insights and intelligent alerting**

### Deliverables

1. **Business Insight Engine** - Automated insight generation
2. **Anomaly Detection** - AI-powered anomaly identification
3. **Alert System** - Threshold-based notifications
4. **Executive Dashboard** - C-level KPI scorecards

### Technical Implementation

#### 2.1 Business Intelligence Engine

```typescript
// Location: admin/src/lib/analytics/BusinessInsightEngine.ts
export class BusinessInsightEngine {
  // Peak hour optimization insights
  static identifyPeakHours(data: HourlyVolumeData[]): PeakHourInsight[];

  // Efficiency pattern analysis
  static analyzeEfficiencyTrend(data: EfficiencyData[]): EfficiencyInsight;

  // Staff utilization insights
  static analyzeStaffUtilization(data: StaffData[]): StaffingInsight[];

  // Customer satisfaction correlation
  static analyzeSatisfactionFactors(
    data: SatisfactionData[]
  ): SatisfactionInsight[];

  // Revenue impact analysis
  static calculateRevenueImpact(data: QueueData[]): RevenueInsight;
}
```

#### 2.2 Anomaly Detection System

```typescript
// Location: admin/src/lib/analytics/AnomalyDetection.ts
export class AnomalyDetectionSystem {
  // Statistical anomaly detection
  static detectStatisticalAnomalies(data: MetricData[]): Anomaly[];

  // Pattern-based anomaly detection
  static detectPatternAnomalies(data: TimeSeriesData[]): PatternAnomaly[];

  // Threshold-based alerts
  static checkThresholdViolations(
    data: MetricData[],
    thresholds: AlertThreshold[]
  ): Alert[];

  // Machine learning anomaly detection
  static detectMLAnomalies(data: FeatureVector[]): MLAnomaly[];
}
```

#### 2.3 Intelligent Alert System

```typescript
// Location: admin/src/app/analytics/components/AlertSystem.tsx
export const AlertSystem: React.FC = () => {
  // Real-time alert monitoring
  // Configurable alert thresholds
  // Multiple notification channels
  // Alert acknowledgment system
  // Historical alert tracking
};
```

#### 2.4 Executive Dashboard

```typescript
// Location: admin/src/app/analytics/components/ExecutiveDashboard.tsx
export const ExecutiveDashboard: React.FC = () => {
  // High-level KPI scorecards
  // Trend indicators
  // Performance benchmarks
  // Action item recommendations
  // Executive summary reports
};
```

### **Phase 2 Success Criteria**

- [ ] Automatic insight generation within 5 minutes of data changes
- [ ] 90%+ accuracy in anomaly detection
- [ ] Alert delivery within 30 seconds of threshold breach
- [ ] Executive dashboard loads in under 2 seconds
- [ ] Business insights provide actionable recommendations

---

## **Phase 3: Predictive Analytics Engine** ‚è±Ô∏è 3 Weeks

_Machine learning and forecasting capabilities_

### **Deliverables**

1. **Time Series Forecasting** - Queue length and wait time predictions
2. **Staffing Optimization** - AI-powered staffing recommendations
3. **Customer Flow Prediction** - Traffic pattern forecasting
4. **Capacity Planning Tools** - Resource optimization insights

### **Technical Implementation**

#### 3.1 Predictive Models Library

```typescript
// Location: admin/src/lib/analytics/PredictiveModels.ts
export class PredictiveModels {
  // Queue length forecasting
  static predictQueueLength(
    historicalData: QueueData[],
    targetHour: number
  ): Prediction;

  // Wait time prediction
  static predictWaitTimes(
    data: WaitTimeData[],
    conditions: PredictionConditions
  ): WaitTimePrediction;

  // Staffing optimization
  static predictStaffingNeeds(
    queuePredictions: Prediction[],
    serviceRate: number
  ): StaffingRecommendation;

  // Customer flow forecasting
  static predictCustomerFlow(
    historicalFlow: FlowData[],
    timeRange: DateRange
  ): FlowPrediction;

  // Capacity planning
  static optimizeCapacity(
    utilizationData: UtilizationData[]
  ): CapacityRecommendation;
}
```

#### 3.2 Machine Learning Pipeline

```typescript
// Location: admin/src/lib/analytics/MLPipeline.ts
export class MLPipeline {
  // Feature engineering
  static extractFeatures(rawData: QueueData[]): FeatureVector[];

  // Model training
  static trainPredictionModel(trainingData: FeatureVector[]): MLModel;

  // Model evaluation
  static evaluateModel(model: MLModel, testData: FeatureVector[]): ModelMetrics;

  // Prediction generation
  static generatePredictions(
    model: MLModel,
    inputData: FeatureVector[]
  ): Prediction[];
}
```

#### 3.3 Forecasting Dashboard

```typescript
// Location: admin/src/app/analytics/components/ForecastingDashboard.tsx
export const ForecastingDashboard: React.FC = () => {
  // Interactive prediction charts
  // Confidence interval displays
  // Model accuracy metrics
  // Scenario planning tools
  // Prediction export functionality
};
```

#### 3.4 Optimization Recommendations

```typescript
// Location: admin/src/app/analytics/components/OptimizationRecommendations.tsx
export const OptimizationRecommendations: React.FC = () => {
  // Staffing recommendations
  // Service time optimization
  // Queue configuration suggestions
  // Resource allocation insights
  // ROI calculations
};
```

### **Phase 3 Success Criteria**

- [ ] Prediction accuracy > 85% for next-hour forecasts
- [ ] Staffing recommendations reduce wait times by 25%
- [ ] Customer flow predictions accurate within 15% margin
- [ ] Capacity optimization increases efficiency by 20%
- [ ] Model retraining completed automatically every week

---

## **Phase 4: Advanced Reporting & Collaboration** ‚è±Ô∏è 2 Weeks

_Custom reporting and enterprise features_

### **Deliverables**

1. **Custom Report Builder** - Drag-and-drop report creation
2. **Scheduled Reports** - Automated report generation and distribution
3. **Collaboration Tools** - Report sharing and commenting
4. **White-label Reporting** - Client-facing report customization

### **Technical Implementation**

#### 4.1 Report Builder Interface

```typescript
// Location: admin/src/app/analytics/components/ReportBuilder.tsx
export const ReportBuilder: React.FC = () => {
  // Drag-and-drop interface
  // Metric selection panel
  // Filter configuration
  // Chart type selection
  // Layout customization
  // Preview functionality
};
```

#### 4.2 Report Generation Engine

```typescript
// Location: admin/src/lib/analytics/ReportGenerator.ts
export class ReportGenerator {
  // Report template processing
  static generateReport(template: ReportTemplate, data: AnalyticsData): Report;

  // Multiple format exports
  static exportToPDF(report: Report): Buffer;
  static exportToExcel(report: Report): Buffer;
  static exportToCSV(report: Report): string;

  // Scheduled generation
  static scheduleReport(
    template: ReportTemplate,
    schedule: CronExpression
  ): ScheduledReport;
}
```

#### 4.3 Collaboration Features

```typescript
// Location: admin/src/app/analytics/components/ReportCollaboration.tsx
export const ReportCollaboration: React.FC = () => {
  // Report sharing controls
  // Comment system
  // Version history
  // Access permissions
  // Notification system
};
```

#### 4.4 White-label Customization

```typescript
// Location: admin/src/app/analytics/components/WhiteLabelReports.tsx
export const WhiteLabelReports: React.FC = () => {
  // Custom branding options
  // Client-specific templates
  // Logo and color customization
  // Custom domain support
  // API-based report distribution
};
```

### **Phase 4 Success Criteria**

- [ ] Report builder supports 20+ visualization types
- [ ] Reports generate in under 10 seconds
- [ ] Scheduled reports deliver 99% reliability
- [ ] White-label customization covers all visual elements
- [ ] Collaboration features support 50+ concurrent users

---

## üìÅ File Structure Plan

```
admin/src/
‚îú‚îÄ‚îÄ lib/analytics/
‚îÇ   ‚îú‚îÄ‚îÄ StatisticalAnalysisEngine.ts
‚îÇ   ‚îú‚îÄ‚îÄ BusinessInsightEngine.ts
‚îÇ   ‚îú‚îÄ‚îÄ AnomalyDetection.ts
‚îÇ   ‚îú‚îÄ‚îÄ PredictiveModels.ts
‚îÇ   ‚îú‚îÄ‚îÄ MLPipeline.ts
‚îÇ   ‚îú‚îÄ‚îÄ ReportGenerator.ts
‚îÇ   ‚îî‚îÄ‚îÄ types/
‚îÇ       ‚îú‚îÄ‚îÄ analytics.ts
‚îÇ       ‚îú‚îÄ‚îÄ predictions.ts
‚îÇ       ‚îî‚îÄ‚îÄ reports.ts
‚îú‚îÄ‚îÄ app/analytics/
‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ RealTimeAnalyticsDashboard.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AlertSystem.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ExecutiveDashboard.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ForecastingDashboard.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ OptimizationRecommendations.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ReportBuilder.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ReportCollaboration.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ WhiteLabelReports.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ charts/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ HeatmapChart.tsx
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ PredictiveChart.tsx
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ TrendAnalysisChart.tsx
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ CorrelationMatrix.tsx
‚îÇ   ‚îî‚îÄ‚îÄ hooks/
‚îÇ       ‚îú‚îÄ‚îÄ useAdvancedAnalyticsProcessing.ts
‚îÇ       ‚îú‚îÄ‚îÄ usePredictiveAnalytics.ts
‚îÇ       ‚îú‚îÄ‚îÄ useReportBuilder.ts
‚îÇ       ‚îî‚îÄ‚îÄ useAlertSystem.ts
```

## üéØ Key Performance Indicators

### **Technical KPIs**

- **Data Processing Speed**: < 2 seconds for 100K records
- **Real-time Updates**: < 1 second latency
- **Prediction Accuracy**: > 85% for short-term forecasts
- **System Uptime**: 99.9% availability
- **Memory Usage**: < 512MB for analytics engine

### **Business KPIs**

- **Insight Generation**: > 95% actionable recommendations
- **User Engagement**: 40% increase in dashboard usage
- **Decision Speed**: 60% faster management decisions
- **Cost Optimization**: 25% reduction in staffing costs
- **Customer Satisfaction**: 20% improvement through optimizations

## üí∞ Resource Requirements

### **Development Time**

- **Phase 1**: 80 hours (2 developers √ó 2 weeks)
- **Phase 2**: 80 hours (2 developers √ó 2 weeks)
- **Phase 3**: 120 hours (2 developers √ó 3 weeks)
- **Phase 4**: 80 hours (2 developers √ó 2 weeks)
- **Total**: 360 hours over 9 weeks

### **Technology Stack Additions**

- **Charting Library**: Chart.js or D3.js for advanced visualizations
- **ML Library**: TensorFlow.js for client-side predictions
- **Report Generation**: jsPDF, ExcelJS for export functionality
- **Scheduling**: node-cron for automated report generation
- **Real-time Processing**: Additional Supabase real-time subscriptions

## üîÑ Implementation Workflow

### **Week 1-2: Phase 1**

1. Set up statistical analysis foundation
2. Implement advanced data processing
3. Create real-time dashboard components
4. Add predictive chart overlays

### **Week 3-4: Phase 2**

1. Build business insight engine
2. Implement anomaly detection
3. Create alert system
4. Design executive dashboard

### **Week 5-7: Phase 3**

1. Develop predictive models
2. Implement ML pipeline
3. Create forecasting dashboard
4. Build optimization recommendations

### **Week 8-9: Phase 4**

1. Build report builder interface
2. Implement scheduled reports
3. Add collaboration features
4. Create white-label customization

## ‚úÖ Testing Strategy

### **Unit Testing**

- Statistical calculations accuracy
- Prediction model performance
- Data processing efficiency
- Component rendering

### **Integration Testing**

- Real-time data flow
- Report generation pipeline
- Alert system functionality
- Multi-user collaboration

### **Performance Testing**

- Large dataset processing
- Concurrent user load
- Memory usage optimization
- Response time benchmarks

### **User Acceptance Testing**

- Dashboard usability
- Report customization
- Insight relevance
- Mobile responsiveness

## üöÄ Deployment Strategy

### **Staging Environment**

- Deploy each phase to staging for testing
- User acceptance testing with stakeholders
- Performance benchmarking
- Bug fixes and optimizations

### **Production Rollout**

- Feature flags for gradual rollout
- A/B testing for new interfaces
- Performance monitoring
- User feedback collection

### **Post-Launch Support**

- Model retraining schedules
- Performance optimization
- User training materials
- Ongoing feature enhancements

---

## üé® UI Library & Visualization Strategy

### **Recommended Approach: Enhanced Current Implementation**

**Keep your current UI foundation** and enhance it with specialized charting libraries:

#### **Technology Stack Additions**

```json
// Add to admin/package.json dependencies
{
  "recharts": "^2.8.0", // Complex charts & animations
  "react-chartjs-2": "^5.2.0", // Specialized chart types
  "chart.js": "^4.4.0", // Chart.js backend
  "d3-scale": "^4.0.2", // Custom scales
  "d3-array": "^3.2.4", // Data processing
  "d3-time-format": "^4.1.0", // Time formatting
  "@tanstack/react-table": "^8.10.0" // Advanced data tables (optional)
}
```

#### **Implementation Strategy**

**Keep Current Components For:**

- KPI Cards and layouts
- Navigation structure
- Form controls
- Basic UI elements
- Existing design system

**Enhance With Specialized Libraries For:**

- Complex charts (heatmaps, multi-axis, predictive overlays)
- Interactive visualizations (drill-down, zoom, pan)
- Real-time charts (streaming data, live updates)
- Advanced data tables (sorting, filtering, pagination)

#### **Example Enhanced Component Implementation**

```typescript
// Enhanced chart component using Recharts + existing design
import {
  LineChart,
  Line,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  ResponsiveContainer,
} from "recharts";

export const EnhancedPredictiveChart: React.FC<PredictiveChartProps> = ({
  data,
  predictions,
  loading,
}) => {
  if (loading) {
    return <YourExistingLoadingSkeleton />;
  }

  return (
    <div className="bg-white rounded-xl border border-gray-200 p-6 shadow-sm">
      {/* Keep your existing header styling */}
      <div className="flex items-center justify-between mb-6">
        <div className="flex items-center space-x-2">
          <TrendingUp className="w-5 h-5 text-blue-600" />
          <h3 className="text-lg font-semibold text-gray-900">
            Queue Predictions
          </h3>
        </div>
      </div>

      {/* Enhanced chart with consistent styling */}
      <div className="h-80">
        <ResponsiveContainer width="100%" height="100%">
          <LineChart data={data}>
            <CartesianGrid strokeDasharray="3 3" stroke="#f1f5f9" />
            <XAxis
              dataKey="time"
              tick={{ fontSize: 12, fill: "#64748b" }}
              tickLine={{ stroke: "#cbd5e1" }}
            />
            <YAxis
              tick={{ fontSize: 12, fill: "#64748b" }}
              tickLine={{ stroke: "#cbd5e1" }}
            />
            <Tooltip
              contentStyle={{
                backgroundColor: "white",
                border: "1px solid #e2e8f0",
                borderRadius: "8px",
                boxShadow: "0 4px 6px -1px rgba(0, 0, 0, 0.1)",
              }}
            />
            <Line
              type="monotone"
              dataKey="actual"
              stroke="#3b82f6"
              strokeWidth={2}
              dot={{ fill: "#3b82f6", strokeWidth: 2, r: 4 }}
              name="Historical"
            />
            <Line
              type="monotone"
              dataKey="predicted"
              stroke="#f59e0b"
              strokeWidth={2}
              strokeDasharray="5 5"
              dot={{ fill: "#f59e0b", strokeWidth: 2, r: 4 }}
              name="Predicted"
            />
          </LineChart>
        </ResponsiveContainer>
      </div>
    </div>
  );
};
```

#### **Chart Library Assignment**

- **Recharts** (Primary): 80% of advanced charts
- **Chart.js + react-chartjs-2**: Complex business charts (gauges, radar)
- **D3 utilities**: Custom calculations and scales
- **Custom SVG**: Simple, fast-loading basic charts

---

## üíª React + Node.js Development Best Practices

### **Code Organization & Structure**

#### **File Size & Complexity Rules**

- **Maximum 500 lines per file** - Break into smaller components/modules
- **Single Responsibility Principle** - One main purpose per file
- **Fragment Early** - Split complex components into logical pieces

#### **Component Fragmentation Strategy**

```typescript
// ‚ùå Bad: Monolithic component (500+ lines)
export const MassiveAnalyticsComponent = () => {
  // Hundreds of lines of mixed logic
};

// ‚úÖ Good: Fragmented approach
export const AnalyticsPage = () => {
  return (
    <div>
      <AnalyticsHeader />
      <AnalyticsFilters />
      <AnalyticsCharts />
      <AnalyticsInsights />
    </div>
  );
};

// Each component < 200 lines, focused responsibility
export const AnalyticsCharts = () => {
  return (
    <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
      <QueueTrendChart />
      <ServiceDistributionChart />
      <PredictiveInsightChart />
    </div>
  );
};
```

#### **Directory Structure Best Practices**

```
src/
‚îú‚îÄ‚îÄ app/analytics/
‚îÇ   ‚îú‚îÄ‚îÄ components/           # Page-specific components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ charts/          # Chart components (< 200 lines each)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ filters/         # Filter components
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ insights/        # Business insight components
‚îÇ   ‚îú‚îÄ‚îÄ hooks/               # Analytics-specific hooks
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ useAnalyticsData.ts      # < 150 lines
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ usePredictiveModel.ts    # < 200 lines
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ useRealTimeMetrics.ts    # < 100 lines
‚îÇ   ‚îú‚îÄ‚îÄ lib/                 # Analytics business logic
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ calculations/    # Pure functions (< 100 lines each)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ models/         # Data models and types
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ utils/          # Utility functions (< 50 lines each)
‚îÇ   ‚îî‚îÄ‚îÄ types/              # TypeScript definitions
‚îú‚îÄ‚îÄ shared/                 # Reusable across apps
‚îÇ   ‚îú‚îÄ‚îÄ components/        # Generic UI components
‚îÇ   ‚îú‚îÄ‚îÄ hooks/            # Shared hooks
‚îÇ   ‚îî‚îÄ‚îÄ utils/            # Cross-app utilities
```

### **Code Quality Standards**

#### **Component Best Practices**

```typescript
// ‚úÖ Clean, focused component (< 150 lines)
interface AnalyticsCardProps {
  title: string;
  value: number | string;
  trend?: "up" | "down" | "neutral";
  loading?: boolean;
}

export const AnalyticsCard: React.FC<AnalyticsCardProps> = ({
  title,
  value,
  trend,
  loading = false,
}) => {
  // Single responsibility: Display analytics card
  // Clear prop types
  // Default values
  // Early returns for loading states

  if (loading) {
    return <CardSkeleton />;
  }

  return (
    <div className="bg-white rounded-lg p-6 shadow-sm border">
      <h3 className="text-sm font-medium text-gray-500">{title}</h3>
      <div className="flex items-center mt-2">
        <span className="text-2xl font-semibold text-gray-900">{value}</span>
        {trend && <TrendIndicator trend={trend} />}
      </div>
    </div>
  );
};
```

#### **Custom Hook Best Practices**

```typescript
// ‚úÖ Focused, reusable hook (< 100 lines)
export const useAnalyticsMetrics = (
  organizationId: string,
  filters: AnalyticsFilters
) => {
  const [data, setData] = useState<AnalyticsData | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Single purpose: Fetch and manage analytics metrics
  // Clear dependencies
  // Proper error handling
  // Memoized calculations

  const processedData = useMemo(() => {
    return data ? processAnalyticsData(data) : null;
  }, [data]);

  useEffect(() => {
    fetchAnalyticsData(organizationId, filters)
      .then(setData)
      .catch((err) => setError(err.message))
      .finally(() => setLoading(false));
  }, [organizationId, filters]);

  return { data: processedData, loading, error, refetch: fetchAnalyticsData };
};
```

#### **Business Logic Separation**

```typescript
// ‚úÖ Pure business logic (< 200 lines)
// Location: lib/analytics/calculations.ts

export class AnalyticsCalculations {
  // Pure functions, easily testable
  static calculateAverageWaitTime(tickets: Ticket[]): number {
    const completedTickets = tickets.filter((t) => t.status === "completed");
    if (completedTickets.length === 0) return 0;

    const totalWaitTime = completedTickets.reduce((sum, ticket) => {
      return sum + this.calculateTicketWaitTime(ticket);
    }, 0);

    return totalWaitTime / completedTickets.length;
  }

  static calculateServiceEfficiency(tickets: Ticket[], staff: number): number {
    const ticketsPerHour = this.calculateTicketsPerHour(tickets);
    const optimalRate = staff * 8; // 8 tickets per staff per hour
    return Math.min((ticketsPerHour / optimalRate) * 100, 100);
  }

  private static calculateTicketWaitTime(ticket: Ticket): number {
    // Implementation details...
  }
}
```

### **Performance Optimization**

#### **Data Processing Best Practices**

```typescript
// ‚úÖ Efficient data processing
export const useOptimizedAnalytics = (rawData: TicketData[]) => {
  // Memoize expensive calculations
  const processedData = useMemo(() => {
    if (!rawData?.length) return null;

    // Process in chunks for large datasets
    return processDataInChunks(rawData, 1000);
  }, [rawData]);

  // Debounce frequent updates
  const debouncedData = useDebounce(processedData, 300);

  return debouncedData;
};

// Utility for processing large datasets
const processDataInChunks = (data: any[], chunkSize: number) => {
  const chunks = [];
  for (let i = 0; i < data.length; i += chunkSize) {
    chunks.push(data.slice(i, i + chunkSize));
  }

  return chunks.reduce((acc, chunk) => {
    return mergeProcessedChunks(acc, processChunk(chunk));
  }, {});
};
```

#### **Memory Management**

```typescript
// ‚úÖ Proper cleanup and memory management
export const useRealTimeAnalytics = (organizationId: string) => {
  const [metrics, setMetrics] = useState<RealTimeMetrics>();

  useEffect(() => {
    const subscription = supabase
      .channel(`analytics-${organizationId}`)
      .on(
        "postgres_changes",
        { event: "*", schema: "public", table: "tickets" },
        (payload) => updateMetrics(payload)
      )
      .subscribe();

    // Cleanup subscriptions
    return () => {
      subscription.unsubscribe();
    };
  }, [organizationId]);

  // Cleanup intervals on unmount
  useEffect(() => {
    const interval = setInterval(() => {
      refreshMetrics();
    }, 30000);

    return () => clearInterval(interval);
  }, []);
};
```

### **Testing Strategy**

#### **Component Testing**

```typescript
// ‚úÖ Focused, maintainable tests
describe("AnalyticsCard", () => {
  it("displays loading state correctly", () => {
    render(<AnalyticsCard title="Test" value="123" loading />);
    expect(screen.getByTestId("card-skeleton")).toBeInTheDocument();
  });

  it("displays analytics data with trend", () => {
    render(<AnalyticsCard title="Queue Length" value="25" trend="up" />);
    expect(screen.getByText("25")).toBeInTheDocument();
    expect(screen.getByTestId("trend-up")).toBeInTheDocument();
  });
});
```

#### **Business Logic Testing**

```typescript
// ‚úÖ Pure function testing
describe("AnalyticsCalculations", () => {
  it("calculates average wait time correctly", () => {
    const tickets = [
      { waitTime: 10, status: "completed" },
      { waitTime: 20, status: "completed" },
      { waitTime: 15, status: "waiting" },
    ];

    expect(AnalyticsCalculations.calculateAverageWaitTime(tickets)).toBe(15);
  });
});
```

### **Error Handling & Resilience**

```typescript
// ‚úÖ Robust error handling
export const useAnalyticsWithFallback = (organizationId: string) => {
  const [data, setData] = useState<AnalyticsData | null>(null);
  const [error, setError] = useState<AnalyticsError | null>(null);

  const fetchWithRetry = async (retries = 3) => {
    try {
      const result = await fetchAnalyticsData(organizationId);
      setData(result);
      setError(null);
    } catch (err) {
      if (retries > 0) {
        await new Promise((resolve) => setTimeout(resolve, 1000));
        return fetchWithRetry(retries - 1);
      }

      setError(new AnalyticsError("Failed to fetch analytics data", err));
      setData(getCachedData(organizationId)); // Fallback to cached data
    }
  };

  return { data, error, refetch: () => fetchWithRetry() };
};
```

### **Development Workflow**

#### **Pre-commit Checklist**

- [ ] Component < 500 lines (fragment if needed)
- [ ] Hook < 200 lines (split if needed)
- [ ] Utility function < 100 lines
- [ ] TypeScript interfaces defined
- [ ] Loading and error states handled
- [ ] Tests written for business logic
- [ ] Performance optimizations applied
- [ ] Memory cleanup implemented

#### **Code Review Guidelines**

- **Readability**: Can new team members understand the code?
- **Responsibility**: Does each file have a single, clear purpose?
- **Reusability**: Can components be used elsewhere?
- **Performance**: Are expensive operations memoized?
- **Error Handling**: Are edge cases covered?

---

## üìû Next Steps

1. **Review and Approval**: Stakeholder review of this plan
2. **Resource Allocation**: Assign development team members
3. **Environment Setup**: Configure development and staging environments
4. **Phase 1 Kickoff**: Begin statistical analysis engine development
5. **UI Library Installation**: Add recommended charting libraries
6. **Code Standards Setup**: Implement development best practices

**Contact**: Development Team  
**Last Updated**: September 1, 2025  
**Next Review**: Weekly progress reviews during implementation
